% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/iprior.R
\name{iprior}
\alias{iprior}
\alias{iprior.default}
\alias{iprior.formula}
\alias{iprior.ipriorKernel}
\alias{iprior.ipriorMod}
\title{Fit an I-prior regression model}
\usage{
\method{iprior}{default}(y, ..., model = list(), control = list())

\method{iprior}{formula}(formula, data = parent.frame(), model = list(),
  control = list(), ...)

\method{iprior}{ipriorKernel}(object, control = list(), ...)

\method{iprior}{ipriorMod}(object, control = list(), ...)
}
\arguments{
\item{y}{Vector of response variables.}

\item{...}{Only used for when fitting using non-formula, enter the variables
(vectors or matrices) separated by commas. No other options applicable here.}

\item{model}{List of model options. Not used for \code{ipriorKernel} or
 \code{ipriorModel} objects. Available options are:
 \describe{\item{\code{kernel}}{Vector of character strings of either
 \code{"Canonical"}, \code{"FBM"}, or \code{"Pearson"}. Defaults to
 \code{"Canonical"} for continuous variables, and \code{"Pearson"} for factor
 type objects.} \item{\code{Hurst}}{The value of the Hurst coefficient when
 using the \code{FBM} kernel. This is a value between 0 and 1. Defaults to
 0.5.}\item{\code{order}}{Character vector of length equal to the number of
 explanatory variables used, indicating specification of higher order scale
 parameters. The syntax is \code{"a^b"}, for parameter \code{a} raised to the
 power \code{b}. For regular order terms, then just input "a".}
 \item{\code{parsm}}{Logical, defaults to \code{TRUE}. Set to \code{FALSE} to
 assign one scale parameter for all kernel matrices.}
 \item{\code{one.lam}}{Logical, defaults to \code{FALSE}. Only relevant when
 using the formula call. Should all the variable share the same scale
 parameter?}}

 These options are also available, but are only relevant when calling using
 non-formula: \describe{\item{\code{yname}}{Character vector to set the name
 of the response variable. It is set to the object name which contains the
 response variables by default.} \item{\code{xname}}{Character vector to set
 the name of the explanatory variables. This is also set to the object name
 by default.} \item{\code{interactions}}{Character vector to specify the
 interaction terms. When using formulas, this is specified automatically.
 Syntax is \code{"a:b"} to indicate variable \code{a} interacts with variable
 \code{b}.}}}

\item{control}{(optional) A list of control options for the EM algorithm and
output: \describe{\item{\code{maxit}}{The maximum number of iterations
until the EM stops. Defaults to \code{50000}} \item{\code{stop.crit}.}{The
EM stopping criteria, which is the difference in succesive log-likelihood
values. Defaults to \code{1e-7}.} \item{\code{progress}}{Option for the
reporting of the EM while the function is running. Choose from one of
\code{"lite"} (default), \code{"full"} (log-likelihood and parameters
trace), \code{"predloglik"} (log-likelihood trace only) or \code{"none"}.}
\item{\code{report}}{The EM reports every \code{report} iterations.
Defaults to \code{100}.} \item{\code{silent}}{Logical, whether the EM
report should be printed or not. This is the same as setting \code{progress
= "none"}.} }}

\item{formula}{The formula to fit when using formula interface.}

\item{data}{Data frame containing variables when using formula interface.}

\item{object}{This is either an object of class formula (when fitting using
formula interface), \code{ipriorKernel} or \code{ipriorModel}. This is used
when not using formula or \code{"y, x"} input.}
}
\value{
An object of class \code{ipriorMod} which is a list of 24 items. The
  more important items are described below. \describe{ \item{\code{alpha,
  lambda, psi, coefficients, sigma}}{The last attained parameter values after
  running the EM algorithm. This can also be extracted via \code{coef()}}
  \item{\code{log.lik}}{The last attained log-likelihood value. This can also
  be extracted via \code{logLik()}.} \item{\code{no.iter}}{The number of
  iterations the EM algorithm ran for.} \item{\code{Hlam.mat}}{This is the
  scaled kernel matrix of dimension \code{n} by \code{n}.}
  \item{\code{VarY.inv}}{The variance-covariance matrix of the marginal
  distribution of \code{y}.} \item{\code{w.hat}}{The vector of posterior mean
  estimates of the I-prior random effects.} \item{\code{fitted.values}}{These
  are posterior estimates of \code{y}, i.e. the fitted values. This can also
  be extracted via \code{fitted()} or \code{\link{predict}()}}
  \item{\code{residuals}}{The vector of residuals. This can also be extracted
  via \code{resid()}.} }
}
\description{
A function to perform linear regression using I-priors. The I-prior model is
fitted via maximum likelihood using an EM algorithm.
}
\details{
The \code{iprior()} function is able to take formula based input and
non-formula. When not using formula, the syntax is as per the default S3
method. That is, the response variable is the vector \code{y}, and any
explanatory variables should follow this, and separated by commas.

As described \link[=kernL]{here}, the model can be loaded first into an
\code{ipriorKernel} object, and then passed to the \code{iprior()} function
to perform the EM algorithm.

If an \code{ipriorMod} object is input, then the EM starts from the last
obtained parameter values. This is particularly useful for very heavy models,
or models which have not yet converged after reaching the maximum number of
iterations. Running \code{iprior()} just continues the EM algorithm.

There are several model options available which primarily controls the number
and placement of scale parameters \code{lambda} in the model, although these
are not applicable when running the function on \code{ipriorMod} or
\code{ipriorKernel} objects.
}
\section{Methods (by class)}{
\itemize{
\item \code{ipriorKernel}: Takes in object of type \code{ipriorKernel} and estimates
the parameters of the model via the EM algorithm.

\item \code{ipriorMod}: Re-run or continue running the EM algorithm from last
attained parameter values in object \code{ipriorMod}.
}}
\examples{
# Formula based input
(mod.stackf <- iprior(stack.loss ~ Air.Flow + Water.Temp + Acid.Conc.,
                      data = stackloss))
mod.toothf <- iprior(len ~ supp * dose, data = ToothGrowth)
summary(mod.toothf)

# Non-formula based input
mod.stacknf <- iprior(y = stackloss$stack.loss,
                      Air.Flow = stackloss$Air.Flow,
                      Water.Temp = stackloss$Water.Temp,
                      Acid.Conc. = stackloss$Acid.Conc.)
mod.toothnf <- iprior(y = ToothGrowth$len,
                      supp = ToothGrowth$supp,
                      dose = ToothGrowth$dose,
                      model = list(interactions = "1:2"))

# Formula based model option one.lam = TRUE
# Sets a single scale parameter for all variables
modf <- iprior(stack.loss ~ ., data = stackloss, model = list(one.lam = TRUE))
modnf <- iprior(y = stackloss$stack.loss, x = stackloss[1:3])

}

